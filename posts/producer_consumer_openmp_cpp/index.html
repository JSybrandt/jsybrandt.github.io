<!DOCTYPE html>
<html lang="">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Justin Sybrandt">
    <meta name="description" content="/">
    <meta name="keywords" content="developer,research,personal,resume,machine,learning">

    <meta property="og:site_name" content="Justin Sybrandt">
    <meta property="og:title" content="
  Producer and Consumer Model in C&#43;&#43; - Justin Sybrandt
">
    <meta property="og:description" content="  Describes a pattern to write really easy parallel code using tasks in OpenMP.
">
    <meta property="og:type" content="website">
    <meta property="og:url" content="/posts/producer_consumer_openmp_cpp/">
    <meta property="og:image" content="/">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="/posts/producer_consumer_openmp_cpp/">
    <meta name="twitter:image" content="/">

    <base href="/posts/producer_consumer_openmp_cpp/">
    <title>
  Producer and Consumer Model in C&#43;&#43; - Justin Sybrandt
</title>

    <link rel="canonical" href="/posts/producer_consumer_openmp_cpp/">
    
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
    
    <link  rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700">
    <link rel="stylesheet" href="/css/normalize.min.css">
    <link rel="stylesheet" href="/css/style.min.css">

    

    

    <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

    
      <link rel="alternate" href="/index.xml" type="application/rss+xml" title="Justin Sybrandt">
      <link href="/index.xml" rel="feed" type="application/rss+xml" title="Justin Sybrandt" />
    



    <meta name="generator" content="Hugo 0.57.2" />
  </head>

  <body class="">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">Justin Sybrandt</a>
    <input type="checkbox" id="menu-control"/>
    <label class="menu-mobile  float-right " for="menu-control">
      <span class="btn-mobile  float-right ">&#9776;</span>
      <ul class="navigation-list">
        
          
            <li class="navigation-item  align-center ">
              <a class="navigation-link" href="/posts">Posts</a>
            </li>
          
            <li class="navigation-item  align-center ">
              <a class="navigation-link" href="/publications">Publications</a>
            </li>
          
            <li class="navigation-item  align-center ">
              <a class="navigation-link" href="/updates">Updates</a>
            </li>
          
            <li class="navigation-item  align-center ">
              <a class="navigation-link" href="/documents/resume.pdf">Resume</a>
            </li>
          
        
        
      </ul>
    </label>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
  <article>
    <header>
      <h1 class="title">Producer and Consumer Model in C&#43;&#43;</h1>
      <h2 class="date">November 6, 2017</h2>
    </header>

    

<p>So recently, I needed to parallelize a lot of my old code.
This initially seemed like a daunting task.
Now its not like I&rsquo;ve never had to write parallel code before, and its not like my task was that hard.
My issue primarily came from a staunch unwillingness to look anything up.
After all, I could just throw my problem into python, right?</p>

<p>While that may be true, the version of myself today would like to tell the version of myself from last week that the C++ solution is not as bad as I thought.</p>

<h2 id="the-task">The Task</h2>

<p>I have a file with 40 million lines, and I have to parse and run a calculation on each.
There are no dependencies between these lines, and the whole thing is just encoded as plain text. A line consists of an id followed by 500 floats, representing a vector in $\Re^{500}$. I just wanted to load each vector and compute two distances.
Based on those distances, I would either keep the vector or throw it away.</p>

<p>Sequentially, this took forever.</p>

<h2 id="the-problem">The Problem</h2>

<p>There are two synchronization points in this task.
Firstly, each line from the file must be read sequentially.
Because the lines are of variable length, I can&rsquo;t do any fancy parallel file system tricks to make loading faster.
Secondly, the resulting data structure, my collection of selected vectors, needs to be protected so two different threads don&rsquo;t try to modify it at the same time.</p>

<p>This means firstly that only a single thread can read from the time at a time, and only a single thread can store its results at a time.
That being said, we are only going to be saving a small fraction of the total vectors.
Also, other threads shouldn&rsquo;t have to wait while the reading thread actually <em>parses</em> the input.</p>

<p>So the idea is pretty simple.
One thread should read from the data file, extracting each line as fast as possible.
We will call this the <strong>producer</strong> thread because it produces work.
The <strong>consumer</strong> threads will be all other threads.</p>

<p>Whenever a new line is found, one of the available threads should take it and start parsing.
Once parsed, the thread can independently do its distance calculations.
If the conditions are right, then the thread should get a lock on the data structure, store its result, and repeat.</p>

<p>In python that&rsquo;s pretty much as easy as:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">doWork</span><span class="p">,</span> <span class="p">[</span><span class="n">line</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">file</span><span class="p">])</span>
<span class="c1"># Note: This line doesn&#39;t do EXACTLY what I just described, but you get the gist.</span></code></pre></div>
<p>How on earth do you do that in C++?</p>

<h2 id="the-c-solution">The C++ Solution</h2>

<p>Okay, we are going to use <a href="http://www.openmp.org/">OpenMP</a> and their <em>#pragma</em> statements.
For unfamiliar readers, these are statements that the compiler will use to do a lot of the gritty parallel work for us.
For the semi-familiar readers, you probably do something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#pragma omp parallel for
</span><span class="cp"></span><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
  <span class="c1">//Make Magic Happen
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
<p>The above code block says <em>&ldquo;Do the following for loop in parallel&rdquo;</em>.
Unsurprisingly, each iteration of the for loop is done be a different thread.
Unfortunately, there is no single <em>#pragma</em> statement for our little producer-consumer idea described above.
That said, its easier than you might think.</p>

<p>The code looks a little something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">DataStructure</span> <span class="n">data</span><span class="p">;</span>
<span class="n">ifstream</span> <span class="n">fileStream</span><span class="p">;</span>
<span class="n">string</span> <span class="n">line</span><span class="p">;</span>

<span class="c1">// ...
</span><span class="c1"></span>
<span class="cp">#pragma omp parallel
</span><span class="cp"></span><span class="p">{</span>
<span class="cp">#pragma omp single
</span><span class="cp"></span>  <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">fileStream</span><span class="p">,</span> <span class="n">line</span><span class="p">)){</span>
<span class="cp">#pragma omp task firstprivate(line)
</span><span class="cp"></span>      <span class="p">{</span>
        <span class="n">Vector</span> <span class="n">vec</span><span class="p">(</span><span class="n">line</span><span class="p">);</span> <span class="c1">// Parse line
</span><span class="c1"></span>        <span class="c1">// Get Work Done
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">condition_met</span><span class="p">){</span>
<span class="cp">#pragma omp critical
</span><span class="cp"></span>          <span class="n">data</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>So whats going on?</p>

<p>First thing first, we get our data setup before the <em>#pragma</em> nonsense.
This is because once we enter these <em>#pragma</em> statements, we are going to be in a new scope, and we won&rsquo;t be able to get the data back out. We enter the new scope with:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#pragma omp parallel
</span><span class="cp"></span><span class="p">{</span>
  <span class="c1">// Everything here is run in parallel.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
<p>This says that the following block will be run using all the threads available on the system.
What confused me at first is that the next line seems to say the opposite:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#pragma omp single
</span><span class="cp"></span><span class="p">{</span>
  <span class="c1">// Everything here is run by one thread.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
<p>This line says that the following block will be run on only <strong>one</strong> of the many threads.
Whats important to note here is that the remaining threads still exist, and are waiting for work.
Its this <em>#pragma</em> which allows us to set up our <strong>producer</strong>.
We get our <strong>consumers</strong> with this:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#pragma omp task
</span><span class="cp"></span><span class="p">{</span>
  <span class="c1">// A new thread takes this work.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
<p>This statement creates work for a <strong>consumer</strong> to take on.
Our single producer thread creates a new task every time they enter the body of our loop.
The option <strong>firstprivate(line)</strong> specifies that each task should copy over its own version of the <strong>line</strong> variable.
That way, each thread doesn&rsquo;t need to worry about it when the <strong>producer</strong> gets a new line.</p>

<p>Finally, we use the following to protect our data structure:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#pragma omp critical
</span><span class="cp"></span><span class="p">{</span>
  <span class="c1">// Only one thread can run this at a time.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
<p>By using the <strong>critical</strong> keyword, we specify that only one thread is allowed to write to our data structure at a time.</p>

<p>And that&rsquo;s it!
Who knew it was so easy to set this up?
All we need to do now is compile our code with the <em>-fopenmp</em> flag and we are off to the races.
I was able to use a 64 core machine at 100% using this method!
Hope this helps you too.</p>

  </article>

  <br/>

  
      <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "sybrandt-com" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  
  
</section>


      </div>
      
        

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>


      
    </main>

    

  <script src="/js/app.js"></script>
  
  </body>
</html>
